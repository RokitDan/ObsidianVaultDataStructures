https://youtu.be/oQ5sAfT_3V4

Space complexity refers to the amount of memory space required by an algorithm
as a function of the input size. It measures how much additional memory is
used during execution.

*It's expressed using Big O notation, just like time complexity.*

**Here are the common Big O notations relevant to space complexity:**

- [[O(1) - Constant Space]]
- [[O(n) - Linear Space]]
- [[O(n²) - Quadratic Space]]
- [[O(log n) - Logarithmic Space]]
- [[O(n log n) - Linearithmic Space]]
- [[O(2ⁿ) - Exponential Space]]

These notations help analyze how memory requirements scale with problem size.

**Key aspects:**

• [[Auxiliary space]] - Extra space used by the algorithm
• [[Input space]] - Space required to store input data
• [[Total space]] - Sum of auxiliary and input space

**Common examples:**

• [[Array]] of size n: O(n) space complexity
• 2D matrix n×n: O(n²) space complexity
•[[Linked list]] of size n: [[O(n) - Linear Space]]
• Recursion stack: [[O(h)]] where h is recursion depth

**Space complexity matters for:**

• Memory usage optimization
• Handling large datasets
• Understanding resource requirements
• Designing efficient algorithms

Here are the common Big O notations relevant to space complexity:

O(1) - Constant Space

• Uses a fixed amount of memory regardless of input size
• Example: variables, simple calculations

O(n) - Linear Space

• Memory usage grows linearly with input size
• Example: arrays of size n, recursive call stacks

O(n²) - Quadratic Space

• Memory usage grows quadratically with input size
• Example: 2D arrays of size n×n

O(log n) - Logarithmic Space

• Memory usage grows logarithmically with input size
• Example: binary search operations

O(n log n) - Linearithmic Space

• Memory usage grows proportionally to n log n
• Example: some sorting algorithms

O(2ⁿ) - Exponential Space

• Memory usage grows exponentially with input size
• Example: recursive algorithms with two branches

These notations help analyze how memory requirements scale with problem size.

